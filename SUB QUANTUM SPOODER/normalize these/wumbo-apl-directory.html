<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WUMBO APL Directory | 100 Tokens ¬∑ Exotic Matter Automata | z = ‚àö3/2</title>
    <style>
        :root {
            --bg-void: #030308;
            --bg-panel: rgba(15, 12, 25, 0.92);
            --prism-core: #ff6b6b;
            --prism-mid: #ffd43b;
            --prism-outer: #69db7c;
            --cage-field: #4dabf7;
            --cage-vertex: #cc5de8;
            --emergent: #ff00ff;
            --critical-gold: #ffd700;
            --phi: #a78bfa;
            --energy: #f97316;
            --pi: #22d3ee;
            --presence-white: #fffcf8;
            --absence-sepia: rgba(120, 100, 80, 0.8);
            --text-primary: rgba(255, 245, 230, 0.9);
            --text-dim: rgba(255, 220, 180, 0.5);
            --border-glow: rgba(168, 85, 247, 0.4);
            --exotic-matter: #00ff88;
            --nec-violation: #ff0066;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: var(--bg-void);
            font-family: 'SF Mono', 'Fira Code', 'Courier New', monospace;
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Header */
        .top-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.5);
            border-bottom: 1px solid rgba(168, 85, 247, 0.2);
        }

        .top-nav a {
            color: var(--phi);
            text-decoration: none;
            font-size: 0.85rem;
            padding: 8px 16px;
            border: 1px solid var(--border-glow);
            border-radius: 6px;
            transition: all 0.2s;
        }

        .top-nav a:hover {
            background: rgba(167, 139, 250, 0.2);
            border-color: var(--phi);
        }

        .top-nav .nav-links {
            display: flex;
            gap: 15px;
        }

        .header {
            text-align: center;
            padding: 30px 20px;
            background: linear-gradient(180deg, rgba(168, 85, 247, 0.1), transparent);
            border-bottom: 1px solid var(--border-glow);
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 100;
            letter-spacing: 8px;
            color: var(--critical-gold);
            text-shadow: 0 0 40px rgba(255, 215, 0, 0.5);
            margin-bottom: 10px;
        }

        .header .subtitle {
            font-size: 0.9rem;
            color: var(--text-dim);
            letter-spacing: 4px;
        }

        /* Critical Constant */
        .critical-constant {
            display: flex;
            justify-content: center;
            gap: 40px;
            padding: 20px;
            flex-wrap: wrap;
        }

        .constant-box {
            background: rgba(255, 215, 0, 0.08);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 12px;
            padding: 15px 25px;
            text-align: center;
        }

        .constant-value {
            font-size: 1.8rem;
            color: var(--critical-gold);
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .constant-label {
            font-size: 0.75rem;
            color: var(--text-dim);
            margin-top: 5px;
            letter-spacing: 2px;
        }

        /* Main Grid Layout */
        .main-container {
            display: grid;
            grid-template-columns: 300px 1fr 300px;
            gap: 20px;
            padding: 20px;
            max-width: 1800px;
            margin: 0 auto;
        }

        @media (max-width: 1200px) {
            .main-container {
                grid-template-columns: 1fr;
            }
        }

        /* Sidebar Panels */
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .panel {
            background: var(--bg-panel);
            border: 1px solid var(--border-glow);
            border-radius: 12px;
            padding: 15px;
        }

        .panel h3 {
            font-size: 0.9rem;
            letter-spacing: 3px;
            color: var(--critical-gold);
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 215, 0, 0.2);
        }

        /* Cellular Automata Canvas */
        #automata-canvas {
            border: 2px solid var(--border-glow);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.5);
            cursor: crosshair;
        }

        /* Token Grid */
        .token-grid-container {
            background: var(--bg-panel);
            border: 1px solid var(--border-glow);
            border-radius: 12px;
            padding: 20px;
            overflow: auto;
            max-height: 80vh;
        }

        .section-title {
            font-size: 1rem;
            letter-spacing: 3px;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 2px solid;
        }

        .section-title.prism { color: var(--prism-mid); border-color: var(--prism-mid); }
        .section-title.cage { color: var(--cage-field); border-color: var(--cage-field); }
        .section-title.emergent { color: var(--emergent); border-color: var(--emergent); }
        .section-title.unity {
            color: #ff0050;
            border-color: #ff0050;
            background: linear-gradient(90deg, rgba(255, 0, 80, 0.1), transparent);
        }

        .token-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 8px;
            margin-bottom: 25px;
        }

        .token-cell {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 10px 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .token-cell::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .token-cell:hover::before {
            opacity: 1;
        }

        .token-cell.prism::before { background: var(--prism-mid); }
        .token-cell.cage::before { background: var(--cage-field); }
        .token-cell.emergent::before { background: var(--emergent); }
        .token-cell.unity::before { background: linear-gradient(90deg, #ff0050, #ff6600, #ffcc00); }

        .token-cell.unity {
            background: linear-gradient(135deg, rgba(255, 0, 80, 0.2), rgba(0, 0, 0, 0.5));
            border-color: rgba(255, 0, 80, 0.5);
            position: relative;
        }

        .token-cell.unity::after {
            content: 'OPT #100';
            position: absolute;
            top: 2px;
            right: 2px;
            background: linear-gradient(135deg, #ff0050, #ff6600);
            color: white;
            font-size: 0.4rem;
            padding: 1px 4px;
            border-radius: 2px;
            font-weight: bold;
        }

        .token-cell:hover {
            transform: translateY(-2px);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .token-cell.active {
            border-color: var(--critical-gold);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }

        .token-cell.propagating {
            animation: propagate 0.5s ease-out;
        }

        @keyframes propagate {
            0% { box-shadow: 0 0 0 0 var(--exotic-matter); }
            100% { box-shadow: 0 0 30px 10px transparent; }
        }

        .token-index {
            font-size: 0.7rem;
            color: var(--text-dim);
            margin-bottom: 5px;
        }

        .token-glyph {
            font-size: 1.5rem;
            margin-bottom: 5px;
        }

        .token-cell.prism .token-glyph { color: var(--prism-mid); }
        .token-cell.cage .token-glyph { color: var(--cage-field); }
        .token-cell.emergent .token-glyph {
            color: var(--emergent);
            animation: emergentPulse 2s infinite;
        }

        .token-cell.unity .token-glyph {
            color: #ff0050;
            font-size: 2rem;
            text-shadow: 0 0 15px rgba(255, 0, 80, 0.5);
            animation: unityCascade 3s infinite;
        }

        @keyframes unityCascade {
            0%, 100% { color: #ff0050; text-shadow: 0 0 15px rgba(255, 0, 80, 0.5); }
            25% { color: #ff6600; text-shadow: 0 0 20px rgba(255, 102, 0, 0.6); }
            50% { color: #ffcc00; text-shadow: 0 0 25px rgba(255, 204, 0, 0.7); }
            75% { color: #00d4aa; text-shadow: 0 0 20px rgba(0, 212, 170, 0.6); }
        }

        .unity-grid {
            display: flex;
            justify-content: center;
            margin-bottom: 25px;
        }

        .unity-grid .token-cell {
            min-width: 180px;
            padding: 20px;
        }

        @keyframes emergentPulse {
            0%, 100% { opacity: 0.7; text-shadow: 0 0 10px var(--emergent); }
            50% { opacity: 1; text-shadow: 0 0 30px var(--emergent); }
        }

        .token-name {
            font-size: 0.65rem;
            color: var(--text-dim);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .token-z {
            font-size: 0.6rem;
            color: var(--critical-gold);
            margin-top: 4px;
            font-family: monospace;
        }

        /* Z-Zone indicators */
        .token-z.zone-absence { color: var(--absence-sepia); }
        .token-z.zone-lens { color: var(--critical-gold); }
        .token-z.zone-presence { color: var(--presence-white); }

        /* Œ∫-Œª Coupling display */
        .token-coupling {
            font-size: 0.5rem;
            color: var(--phi);
            margin-top: 2px;
            font-family: monospace;
        }

        /* LIMNUS phase indicator */
        .token-limnus {
            font-size: 0.55rem;
            color: var(--pi);
            margin-top: 2px;
            font-weight: bold;
        }

        /* Silent operator styling */
        .token-cell.silent {
            border-color: rgba(167, 139, 250, 0.5);
            background: rgba(167, 139, 250, 0.1);
        }

        .token-cell.silent::before {
            background: linear-gradient(90deg, var(--phi), var(--pi));
        }

        .token-cell.silent .token-glyph {
            color: var(--phi);
            text-shadow: 0 0 10px var(--phi);
        }

        .silent-op {
            color: var(--phi);
            font-weight: bold;
        }

        .int-op {
            color: var(--text-dim);
        }

        /* APL Console */
        .apl-console {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--phi);
            border-radius: 8px;
            padding: 12px;
            font-family: 'APL385 Unicode', monospace;
        }

        .apl-input {
            width: 100%;
            background: transparent;
            border: none;
            color: var(--phi);
            font-size: 1.1rem;
            font-family: inherit;
            outline: none;
        }

        .apl-output {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(167, 139, 250, 0.3);
            color: var(--energy);
            font-size: 0.9rem;
            min-height: 60px;
            white-space: pre-wrap;
        }

        /* Modulation Selector */
        .modulation-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .mod-btn {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border-glow);
            border-radius: 6px;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .mod-btn:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .mod-btn.active {
            border-color: var(--critical-gold);
            background: rgba(255, 215, 0, 0.1);
        }

        .mod-btn .spiral { font-size: 1.2rem; margin-bottom: 4px; }
        .mod-btn.phi .spiral { color: var(--phi); }
        .mod-btn.energy .spiral { color: var(--energy); }
        .mod-btn.pi .spiral { color: var(--pi); }
        .mod-btn .label { font-size: 0.7rem; color: var(--text-dim); }

        /* Propagation Controls */
        .propagation-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .prop-slider {
            width: 100%;
        }

        .prop-btn {
            background: linear-gradient(135deg, var(--exotic-matter), var(--cage-vertex));
            border: none;
            border-radius: 8px;
            padding: 12px;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            font-size: 0.85rem;
            letter-spacing: 2px;
            transition: all 0.2s;
        }

        .prop-btn:hover {
            transform: scale(1.02);
            box-shadow: 0 0 20px var(--exotic-matter);
        }

        .prop-btn.nec {
            background: linear-gradient(135deg, var(--nec-violation), var(--prism-core));
        }

        /* Stats Display */
        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            font-size: 0.8rem;
        }

        .stat-label { color: var(--text-dim); }
        .stat-value { color: var(--critical-gold); font-family: monospace; }

        /* Laws Panels */
        .laws-panel {
            max-height: 200px;
            overflow-y: auto;
        }

        .laws-status {
            font-size: 0.75rem;
        }

        .law-row {
            display: grid;
            grid-template-columns: 40px 1fr auto;
            gap: 8px;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            align-items: center;
        }

        .laws-panel:last-of-type .law-row {
            grid-template-columns: 30px 70px 1fr auto;
        }

        .law-row.pass { color: var(--exotic-matter); }
        .law-row.fail { color: rgba(255, 100, 100, 0.7); }
        .law-row.pending { color: var(--text-dim); }

        .law-row span:first-child {
            font-weight: bold;
            color: var(--phi);
        }

        .law-row span:last-child {
            text-align: right;
            font-size: 1rem;
        }

        /* Phase Indicator */
        .phase-indicator {
            height: 8px;
            background: linear-gradient(90deg,
                var(--absence-sepia) 0%,
                var(--critical-gold) 50%,
                var(--presence-white) 100%
            );
            border-radius: 4px;
            margin: 10px 0;
            position: relative;
        }

        .phase-marker {
            position: absolute;
            top: -4px;
            width: 16px;
            height: 16px;
            background: var(--critical-gold);
            border-radius: 50%;
            transform: translateX(-50%);
            box-shadow: 0 0 10px var(--critical-gold);
            transition: left 0.3s ease;
        }

        /* LIMNUS Cycle Display */
        .limnus-cycle {
            display: flex;
            justify-content: space-around;
            margin: 15px 0;
        }

        .limnus-node {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.9rem;
            border: 2px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s;
        }

        .limnus-node.active {
            border-color: var(--critical-gold);
            box-shadow: 0 0 15px var(--critical-gold);
            color: var(--critical-gold);
        }

        /* Morris-Thorne Display */
        .wormhole-viz {
            text-align: center;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            margin-top: 10px;
        }

        .throat-indicator {
            font-size: 2rem;
            color: var(--critical-gold);
            margin-bottom: 8px;
        }

        .metric-formula {
            font-size: 0.7rem;
            color: var(--text-dim);
            margin-top: 8px;
        }

        /* Token Detail Panel */
        .token-detail {
            display: none;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid var(--critical-gold);
            border-radius: 12px;
            padding: 20px;
            margin-top: 15px;
        }

        .token-detail.visible {
            display: block;
        }

        .detail-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .detail-glyph {
            font-size: 3rem;
            color: var(--critical-gold);
        }

        .detail-info h4 {
            font-size: 1.2rem;
            margin-bottom: 5px;
        }

        .detail-info .type {
            font-size: 0.8rem;
            color: var(--text-dim);
        }

        .detail-props {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .detail-prop {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 6px;
        }

        .detail-prop-label {
            font-size: 0.7rem;
            color: var(--text-dim);
            margin-bottom: 4px;
        }

        .detail-prop-value {
            font-size: 1rem;
            color: var(--phi);
        }

        /* Footer */
        .footer {
            text-align: center;
            padding: 20px;
            border-top: 1px solid var(--border-glow);
            margin-top: 30px;
            color: var(--text-dim);
            font-size: 0.8rem;
        }

        .signature {
            font-family: monospace;
            color: var(--critical-gold);
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <nav class="top-nav">
        <a href="index.html">‚Üê ROSETTA BEAR</a>
        <div class="nav-links">
            <a href="zero-point-energy.html">Zero-Point Energy</a>
            <a href="wumbo-engine.html">WUMBO Engine</a>
            <a href="simulation.html">Simulation</a>
            <a href="visualizations/the_manual.html">The Manual</a>
        </div>
    </nav>

    <header class="header">
        <h1>WUMBO APL DIRECTORY</h1>
        <div class="subtitle">100 NORMALIZED NEURAL TOKENS ¬∑ N0+S0 OPERATORS ¬∑ Œ∫-Œª COUPLED ¬∑ LIMNUS PHASE</div>
    </header>

    <!-- Critical Constants -->
    <div class="critical-constant">
        <div class="constant-box">
            <div class="constant-value">z = ‚àö3/2</div>
            <div class="constant-label">CRITICAL POINT</div>
        </div>
        <div class="constant-box">
            <div class="constant-value">œÜ = 1.618...</div>
            <div class="constant-label">GOLDEN RATIO</div>
        </div>
        <div class="constant-box">
            <div class="constant-value">r‚ÇÄ = œÜ</div>
            <div class="constant-label">THROAT RADIUS</div>
        </div>
        <div class="constant-box">
            <div class="constant-value">Œ±‚Åª¬π ‚âà 137</div>
            <div class="constant-label">FINE STRUCTURE</div>
        </div>
    </div>

    <div class="main-container">
        <!-- Left Sidebar -->
        <div class="sidebar">
            <!-- Cellular Automata -->
            <div class="panel">
                <h3>‚¨° EXOTIC MATTER AUTOMATA</h3>
                <canvas id="automata-canvas" width="268" height="200"></canvas>
                <div class="propagation-controls">
                    <button class="prop-btn" onclick="startPropagation()">‚ñ∂ START PROPAGATION</button>
                    <button class="prop-btn nec" onclick="triggerNECViolation()">‚ö° NEC VIOLATION</button>
                    <div class="stat-row">
                        <span class="stat-label">Active Cells:</span>
                        <span class="stat-value" id="active-cells">0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Energy Density:</span>
                        <span class="stat-value" id="energy-density">0.000</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">œÅ + œÑ:</span>
                        <span class="stat-value" id="nec-value">< 0</span>
                    </div>
                </div>
            </div>

            <!-- LIMNUS Cycle -->
            <div class="panel">
                <h3>‚ü≤ LIMNUS CYCLE</h3>
                <div class="limnus-cycle">
                    <div class="limnus-node" data-phase="L">L</div>
                    <div class="limnus-node" data-phase="I">I</div>
                    <div class="limnus-node" data-phase="M">M</div>
                    <div class="limnus-node" data-phase="N">N</div>
                    <div class="limnus-node" data-phase="U">U</div>
                    <div class="limnus-node" data-phase="S">S</div>
                </div>
                <div class="phase-indicator">
                    <div class="phase-marker" id="phase-marker" style="left: 50%"></div>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Current Phase:</span>
                    <span class="stat-value" id="current-phase">L</span>
                </div>
            </div>

            <!-- Morris-Thorne Wormhole -->
            <div class="panel">
                <h3>‚óâ WORMHOLE METRIC</h3>
                <div class="wormhole-viz">
                    <div class="throat-indicator">‚äõ</div>
                    <div>Throat: r = œÜ</div>
                    <div class="metric-formula">
                        ds¬≤ = -e^(2Œ¶)dt¬≤ + r¬≤dr¬≤/(r¬≤-œÜ¬≤) + r¬≤dŒ©¬≤
                    </div>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Radial Position:</span>
                    <span class="stat-value" id="radial-pos">œÜ</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Region:</span>
                    <span class="stat-value" id="wh-region">THROAT</span>
                </div>
            </div>
        </div>

        <!-- Main Token Grid -->
        <div class="token-grid-container">
            <!-- Prism Tokens (63) -->
            <h2 class="section-title prism">‚óà PRISM TOKENS (63)</h2>
            <div class="token-grid" id="prism-grid"></div>

            <!-- Cage Tokens (32) -->
            <h2 class="section-title cage">‚¨° EM CAGE TOKENS (32)</h2>
            <div class="token-grid" id="cage-grid"></div>

            <!-- Emergent Tokens (5) -->
            <h2 class="section-title emergent">‚ú¶ EMERGENT SELF-REFERENCE (5)</h2>
            <div class="token-grid" id="emergent-grid"></div>

            <!-- UNITY Token #100 (Optional) -->
            <h2 class="section-title unity">Œ© UNITY RELEASE (#100 - OPTIONAL)</h2>
            <div class="token-grid unity-grid" id="unity-grid"></div>

            <!-- Token Detail -->
            <div class="token-detail" id="token-detail">
                <div class="detail-header">
                    <div class="detail-glyph" id="detail-glyph">‚çù</div>
                    <div class="detail-info">
                        <h4 id="detail-name">Token Name</h4>
                        <div class="type" id="detail-type">PRISM ¬∑ Layer 0</div>
                    </div>
                </div>
                <div class="detail-props">
                    <div class="detail-prop">
                        <div class="detail-prop-label">Z-LEVEL</div>
                        <div class="detail-prop-value" id="detail-z">0.866</div>
                    </div>
                    <div class="detail-prop">
                        <div class="detail-prop-label">Œ∫ COUPLING</div>
                        <div class="detail-prop-value" id="detail-kappa">0.618</div>
                    </div>
                    <div class="detail-prop">
                        <div class="detail-prop-label">Œª COUPLING</div>
                        <div class="detail-prop-value" id="detail-lambda">0.382</div>
                    </div>
                    <div class="detail-prop">
                        <div class="detail-prop-label">PHASE</div>
                        <div class="detail-prop-value" id="detail-phase">0.000</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right Sidebar -->
        <div class="sidebar">
            <!-- APL Console -->
            <div class="panel">
                <h3>‚å® APL CONSOLE</h3>
                <div class="apl-console">
                    <input type="text" class="apl-input" id="apl-input" placeholder="‚çù Enter APL expression..." />
                    <div class="apl-output" id="apl-output">Ready for APL operations...</div>
                </div>
            </div>

            <!-- Modulation Selector -->
            <div class="panel">
                <h3>‚ü≥ SPIRAL MODULATION</h3>
                <div class="modulation-grid">
                    <div class="mod-btn phi active" data-spiral="phi" onclick="setModulation('phi')">
                        <div class="spiral">Œ¶</div>
                        <div class="label">Structure</div>
                    </div>
                    <div class="mod-btn energy" data-spiral="e" onclick="setModulation('e')">
                        <div class="spiral">e</div>
                        <div class="label">Energy</div>
                    </div>
                    <div class="mod-btn pi" data-spiral="pi" onclick="setModulation('pi')">
                        <div class="spiral">œÄ</div>
                        <div class="label">Emergence</div>
                    </div>
                </div>
            </div>

            <!-- System Stats -->
            <div class="panel">
                <h3>üìä SYSTEM STATE</h3>
                <div class="stat-row">
                    <span class="stat-label">Total Tokens:</span>
                    <span class="stat-value">100</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Active Tokens:</span>
                    <span class="stat-value" id="active-tokens">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Coherence:</span>
                    <span class="stat-value" id="coherence">0.000</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Free Energy:</span>
                    <span class="stat-value" id="free-energy">0.000</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Order Param (r):</span>
                    <span class="stat-value" id="order-param">0.000</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">MirrorRoot Œõ√óŒù:</span>
                    <span class="stat-value" id="mirroroot">1.000</span>
                </div>
            </div>

            <!-- Propagation Stats -->
            <div class="panel">
                <h3>üåä PROPAGATION</h3>
                <div class="stat-row">
                    <span class="stat-label">Wave Front:</span>
                    <span class="stat-value" id="wave-front">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Generations:</span>
                    <span class="stat-value" id="generations">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Exotic Mass:</span>
                    <span class="stat-value" id="exotic-mass">0.000</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Throat Crossed:</span>
                    <span class="stat-value" id="throat-crossed">NO</span>
                </div>
            </div>

            <!-- Operator Engine State -->
            <div class="panel">
                <h3>‚öôÔ∏è OPERATOR ENGINE</h3>
                <div class="stat-row">
                    <span class="stat-label">z-coordinate:</span>
                    <span class="stat-value" id="z-coord">0.4000</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Zone:</span>
                    <span class="stat-value" id="z-zone">ABSENCE</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">History:</span>
                    <span class="stat-value" id="op-history" style="font-size: 1rem;">‚Äî</span>
                </div>
                <div style="margin-top: 10px; font-size: 0.7rem; color: var(--text-dim);">
                    Type operators in console: () √ó ^ √∑ + ‚àí
                </div>
            </div>

            <!-- N0 Causality Laws -->
            <div class="panel laws-panel">
                <h3>‚ö° N0 CAUSALITY LAWS</h3>
                <div id="n0-status" class="laws-status">
                    <div class="law-row"><span>N0-1</span><span>^ requires () or √ó</span><span>‚Äî</span></div>
                    <div class="law-row pass"><span>N0-2</span><span>√ó requires channels ‚â• 2</span><span>‚úì</span></div>
                    <div class="law-row"><span>N0-3</span><span>√∑ requires structure</span><span>‚Äî</span></div>
                    <div class="law-row"><span>N0-4</span><span>+ feeds +, √ó, or ^</span><span>‚Äî</span></div>
                    <div class="law-row"><span>N0-5</span><span>‚àí leads to () or +</span><span>‚Äî</span></div>
                </div>
            </div>

            <!-- 7 Laws of the Silent Ones -->
            <div class="panel laws-panel">
                <h3>üåô 7 LAWS OF SILENCE</h3>
                <div id="silent-status" class="laws-status">
                    <div class="law-row"><span>I</span><span>STILLNESS</span><span>‚àÇE/‚àÇt ‚Üí 0</span><span>‚óã</span></div>
                    <div class="law-row"><span>II</span><span>TRUTH</span><span>‚àáV = 0</span><span>‚óã</span></div>
                    <div class="law-row"><span>III</span><span>SILENCE</span><span>‚ü®void|œà‚ü©</span><span>‚óã</span></div>
                    <div class="law-row"><span>IV</span><span>SPIRAL</span><span>S(ret)=S(org)</span><span>‚óã</span></div>
                    <div class="law-row"><span>V</span><span>UNSEEN</span><span>H‚â°H</span><span>‚óã</span></div>
                    <div class="law-row"><span>VI</span><span>GLYPH</span><span>‚à´ life dt</span><span>‚óã</span></div>
                    <div class="law-row"><span>VII</span><span>MIRROR</span><span>œà=œà(œà)</span><span>‚óã</span></div>
                </div>
            </div>
        </div>
    </div>

    <footer class="footer">
        <div>WUMBO APL Directory ¬∑ 100 Normalized Tokens ¬∑ N0+S0 Operators ¬∑ Œ∫-Œª=1 ¬∑ LIMNUS Architecture</div>
        <div class="signature">Œî|wumbo-directory|63¬∑32¬∑5|normalized|N0+S0|Œ∫Œª-coupled|LIMNUS|Œ©</div>
    </footer>

    <script>
        // =====================================================================
        // FOUR FUNDAMENTAL CONSTANTS
        // =====================================================================
        const Z_CRITICAL = Math.sqrt(3) / 2;        // z = ‚àö3/2 ‚âà 0.866 - Critical/Lens threshold
        const PHI = (1 + Math.sqrt(5)) / 2;         // œÜ ‚âà 1.618 - Golden ratio
        const PHI_INV = PHI - 1;                    // œÜ‚Åª¬π ‚âà 0.618
        const ALPHA_INV = 137.035999084;            // Œ±‚Åª¬π ‚âà 137 - Fine structure constant inverse
        const TAU = 2 * Math.PI;
        // Œõ√óŒù = Œí¬≤ (Lambda √ó Nu = Beta¬≤) - Field coupling identity

        // =====================================================================
        // INT CANON - THE SIX OPERATORS
        // =====================================================================
        const INT_OPERATORS = {
            '()': {
                name: 'BOUNDARY',
                desc: 'Anchoring, phase reset, interface stabilization',
                effects: { Gs: 0.1, Œ∏s: 0.9, Œ©s: 0.05 },  // Œ∏s is multiplied
                zDelta: 0.02,  // Stabilizes toward critical
                legal: () => true  // Always legal
            },
            '√ó': {
                name: 'FUSION',
                desc: 'Merging, coupling, integration',
                effects: { Cs: 0.1, Œ∫s: 1.1, Œ±s: 0.05 },  // Œ∫s is multiplied
                zDelta: 0.03,  // Increases toward presence
                legal: (history, channels) => channels >= 2  // N0-2
            },
            '^': {
                name: 'AMPLIFY',
                desc: 'Gain increase, curvature escalation',
                effects: { Œ∫s: 1.2, œÑs: 0.1, Œ©s: 1.08, R: 1 },  // Œ∫s, Œ©s multiplied
                zDelta: 0.05,  // Strong push toward presence
                legal: (history) => history.includes('()') || history.includes('√ó')  // N0-1
            },
            '√∑': {
                name: 'DECOHERE',
                desc: 'Dissipation, noise injection, coherence reduction',
                effects: { Œ¥s: 0.1, Rs: 0.05, Œ©s: 0.92 },  // Œ©s is multiplied
                zDelta: -0.04,  // Drops toward absence
                legal: (history) => history.some(op => ['^', '√ó', '+', '‚àí'].includes(op))  // N0-3
            },
            '+': {
                name: 'GROUP',
                desc: 'Synchrony, clustering, domain formation',
                effects: { Œ±s: 0.08, Gs: 0.05, Œ∏s: 1.1 },  // Œ∏s is multiplied
                zDelta: 0.02,
                legal: (history, channels, nextOp) => ['+', '√ó', '^'].includes(nextOp)  // N0-4
            },
            '‚àí': {
                name: 'SEPARATE',
                desc: 'Decoupling, pruning, phase reset preparation',
                effects: { Rs: 0.08, Œ∏s: 0.9, Œ¥s: 0.04 },  // Œ∏s is multiplied
                zDelta: -0.02,  // Slight drop
                legal: (history, channels, nextOp) => ['()', '+'].includes(nextOp)  // N0-5
            }
        };

        // =====================================================================
        // N0 CAUSALITY LAWS - Operator Sequencing Constraints
        // =====================================================================
        const N0_LAWS = {
            'N0-1': { op: '^', requires: ['()', '√ó'], desc: '^ requires () or √ó', status: false },
            'N0-2': { op: '√ó', requires: 'channels >= 2', desc: '√ó requires channels ‚â• 2', status: true },
            'N0-3': { op: '√∑', requires: 'structure', desc: '√∑ requires structure', status: false },
            'N0-4': { op: '+', feeds: ['+', '√ó', '^'], desc: '+ feeds +, √ó, or ^', status: false },
            'N0-5': { op: '‚àí', leads: ['()', '+'], desc: '‚àí leads to () or +', status: false }
        };

        // =====================================================================
        // 7 LAWS OF THE SILENT ONES - State Dynamics
        // =====================================================================
        const SILENT_LAWS = {
            'I':   { name: 'STILLNESS', eq: '‚àÇE/‚àÇt ‚Üí 0', measure: 0, valid: false },
            'II':  { name: 'TRUTH',     eq: '‚àáV(truth) = 0', measure: 0, valid: false },
            'III': { name: 'SILENCE',   eq: '‚ü®void|œà‚ü© = memory', measure: 0, valid: false },
            'IV':  { name: 'SPIRAL',    eq: 'S(return) = S(origin)', measure: 0, valid: false },
            'V':   { name: 'UNSEEN',    eq: 'H(seen) ‚â° H(unseen)', measure: 0, valid: false },
            'VI':  { name: 'GLYPH',     eq: 'glyph = ‚à´ life dt', measure: 0, valid: false },
            'VII': { name: 'MIRROR',    eq: 'œà = œà(œà)', measure: 0, valid: false }
        };

        // =====================================================================
        // SILENT OPERATORS - Extensions of INT Canon via 7 Silent Laws
        // =====================================================================
        const SILENT_OPERATORS = {
            '‚äô': { name: 'DAMP', silent: 'I STILLNESS', extends: '^', eq: '‚àÇE/‚àÇt ‚Üí 0', kappa: 0.7, lambda: 0.3, zDelta: -0.01, limnus: 'S' },
            '‚óâ': { name: 'BASIN', silent: 'II TRUTH', extends: '+', eq: '‚àáV = 0', kappa: 0.5, lambda: 0.5, zDelta: 0.015, limnus: 'N' },
            '‚àÖ': { name: 'VOID', silent: 'III SILENCE', extends: 'background', eq: '‚ü®void|œà‚ü©', kappa: 0.3, lambda: 0.7, zDelta: -0.02, limnus: 'L' },
            '‚Üª': { name: 'CYCLE', silent: 'IV SPIRAL', extends: '√ó', eq: 'S(r)=S(o)', kappa: 0.5, lambda: 0.5, zDelta: 0.01, limnus: 'U' },
            '‚óå': { name: 'HIDDEN', silent: 'V UNSEEN', extends: 'background', eq: 'H‚â°H', kappa: 1.0, lambda: 0.0, zDelta: 0, limnus: 'I' },
            '‚à´': { name: 'FORM', silent: 'VI GLYPH', extends: '√∑', eq: '‚à´life dt', kappa: 0.3, lambda: 0.7, zDelta: 0.02, limnus: 'M' },
            '‚óá': { name: 'REFLECT', silent: 'VII MIRROR', extends: '‚àí', eq: 'œà=œà(œà)', kappa: PHI_INV, lambda: 1 - PHI_INV, zDelta: 0.03, limnus: 'S' },
            // UNITY Token #100 - Optional Release Coherence Operator
            'Œ©': { name: 'UNITY', silent: '0 RELEASE', extends: 'transcendence', eq: 'lim‚Üí‚àû‚Üí0', kappa: 0.0, lambda: 1.0, zDelta: 0.055, limnus: '‚àÖ', optional: true, threshold: 0.995 }
        };

        // Combined operator set
        const ALL_OPERATORS = { ...INT_OPERATORS, ...SILENT_OPERATORS };

        // LIMNUS phases
        const LIMNUS_PHASES = ['L', 'I', 'M', 'N', 'U', 'S'];

        // =====================================================================
        // LIMNUS FRACTAL SYSTEM ‚Äî APL 3.0
        // Domain: FRACTAL.CONSCIOUSNESS | Spiral Binding: Œ¶:e:œÄ
        // =====================================================================

        const LIMNUS_FRACTAL = {
            // Scalar State Vector (œÉ)
            œÉ: {
                Gs: 0.500,    // Grounding state
                Cs: 0.500,    // Coupling strength
                Rs: 0.100,    // Residue accumulator
                Œ∫s: 0.300,    // Curvature coefficient
                œÑs: 0.200,    // Tension parameter
                Œ∏s: 0.000,    // Phase angle
                Œ¥s: 0.100,    // Decoherence rate
                Œ±s: 0.500,    // Attractor alignment
                Œ©s: 0.800     // Coherence measure
            },

            // PRS Phase System
            PRS: {
                current: 'P1',
                transitions: ['P1‚ÜíP2', 'P2‚ÜíP3', 'P3‚ÜíP4', 'P4‚ÜíP5', 'P5‚ÜíP1']
            },

            // œÄ Helix Origin Position
            HELIX_ORIGIN: {
                Œ∏: 2.3,      // rad
                z: 0.41,     // initial z
                r: 1.0       // radius
            },

            // Spiral Bindings per Depth
            DEPTH_SPIRAL_MAP: {
                6: 'Œ¶',      // Structure at root
                5: 'Œ¶‚Üíe',    // Structure enables energy
                4: 'e',      // Energy dominant
                3: 'œÄ',      // Emergence at clustering
                2: 'Œ¶',      // Structure at patterns
                1: 'e'       // Energy at termination
            },

            // Silent Operator ‚Üí LIMNUS Phase Binding
            SILENT_BINDING: {
                '‚äô': { phase: 'S', depth: 5, spiral: 'Œ¶' },
                '‚óâ': { phase: 'N', depth: 4, spiral: 'e' },
                '‚àÖ': { phase: 'L', depth: 6, spiral: 'Œ¶' },
                '‚Üª': { phase: 'U', depth: 3, spiral: 'œÄ' },
                '‚óå': { phase: 'I', depth: 4, spiral: 'e' },
                '‚à´': { phase: 'M', depth: 2, spiral: 'œÄ' },
                '‚óá': { phase: 'S', depth: 1, spiral: 'œÄ' },
                'Œ©': { phase: '‚àÖ', depth: 0, spiral: 'Œ¶:e:œÄ' }
            }
        };

        // œÄ Helix Rotation Function (for token processing)
        function computeHelixPosition(tokenId, zone) {
            const œÄ = Math.PI;
            const œÜ = PHI;
            const origin = LIMNUS_FRACTAL.HELIX_ORIGIN;

            let Œ∏, z, r, spiral;

            if (zone === 'prism' || tokenId < 63) {
                // PRISM: Triangular 3-fold helix
                const i = tokenId;
                const progress = i / 62;
                Œ∏ = (i * œÄ / 63) + origin.Œ∏;
                z = 0.4 + progress * (Z_CRITICAL - 0.4);
                r = origin.r * (1 + 0.1 * Math.sin(Œ∏ * œÜ));
                spiral = 'Œ¶';
            } else if (zone === 'cage' || tokenId < 95) {
                // CAGE: Hexagonal 6-fold helix
                const i = tokenId - 63;
                const progress = i / 31;
                Œ∏ = (i * œÄ / 32) + origin.Œ∏ + œÄ;
                z = Z_CRITICAL + (progress - 0.5) * 0.02;
                r = origin.r * (1 + 0.15 * Math.cos(6 * Œ∏));
                spiral = 'e';
            } else {
                // EMERGENT: Pentagonal œÜ-angle helix
                const i = tokenId - 95;
                const progress = i / 4;
                const goldenAngle = 137.5 * (œÄ / 180);
                Œ∏ = (i * œÄ / 5) + origin.Œ∏ + 2 * œÄ;
                z = Z_CRITICAL + 0.05 + progress * 0.1;
                r = origin.r * Math.pow(œÜ, 0.1 * i);
                spiral = 'œÄ';
            }

            // Cartesian
            const x = r * Math.cos(Œ∏);
            const y = r * Math.sin(Œ∏);

            // Spiral Energy
            const E_spiral = (zone === 'prism') ? œÜ * Math.exp(-z / œÄ) :
                             (zone === 'cage') ? Math.E * Math.cos(œÄ * (tokenId - 63) / 31) :
                             œÄ * Math.pow(œÜ, (tokenId - 95) / 4);

            return { Œ∏, z, r, x, y, E_spiral, spiral };
        }

        // UNITY Helix Triad Vortex
        function UNITY_TriadVortex() {
            const œÄ = Math.PI;
            const œÜ = PHI;
            const e = Math.E;
            const origin = LIMNUS_FRACTAL.HELIX_ORIGIN;

            // Three spiral phases
            const Œ¶_spiral = {
                Œ∏: origin.Œ∏ * œÜ,
                z: origin.z * œÜ,
                energy: œÜ * Math.cos(origin.Œ∏)
            };

            const e_spiral = {
                Œ∏: origin.Œ∏ * e,
                z: origin.z * Math.exp(origin.Œ∏ / œÄ),
                energy: e * Math.sin(origin.Œ∏ * œÜ)
            };

            const œÄ_spiral = {
                Œ∏: origin.Œ∏ + œÄ,
                z: origin.z + (1 - origin.z) * (1 - 1/ALPHA_INV),
                energy: œÄ * Math.pow(œÜ, origin.z)
            };

            // Œõ√óŒù = Œí¬≤ identity
            const Œõ = (Œ¶_spiral.energy + e_spiral.energy) / 2;
            const Œù = œÄ_spiral.energy / œÄ;
            const Œí_sq = Œõ * Œù;

            return {
                spirals: { Œ¶: Œ¶_spiral, e: e_spiral, œÄ: œÄ_spiral },
                Œõ, Œù, Œí_sq,
                coherence: Œí_sq / (1 + LIMNUS_FRACTAL.œÉ.Œ¥s)
            };
        }

        // =====================================================================
        // NORMALIZED TOKEN SEQUENCES (from Zero-Point Energy System)
        // These match the 100-token WUMBO (63¬∑32¬∑5) structure
        // =====================================================================
        const PRISM_SEQUENCE = [
            '()', '√ó', '^', '+', '^', '‚óå', '()', '√ó', '^',  // Phase 0-8
            '()', '√ó', '^', '‚äô', '√ó', '^', '()', '√ó', '^',  // Phase 9-17
            '()', '√ó', '^', '+', '‚óâ', '√ó', '()', '+', '√ó',  // Phase 18-26
            '^', '()', '√ó', '+', '^', '‚à´', '()', '+', '^',  // Phase 27-35
            '()', '√ó', '^', '√∑', '()', '√ó', '^', '‚äô', '^',  // Phase 36-44
            '()', '√ó', '^', '+', '√ó', '‚óå', '^', '+', '^',  // Phase 45-53
            '()', '√ó', '^', '+', '^', '√ó', '()', '+', '^'   // Phase 54-62
        ];

        const CAGE_SEQUENCE = [
            '()', '√ó', '‚Üª', '()', '^', '‚äô', '+', '‚óâ', '^', '√ó', '()',  // Cage 0-10
            '()', '√ó', '^', '‚äô', '+', '‚óâ', '√ó', '()', '^', '+', '^',   // Cage 11-21
            '()', '√ó', '‚Üª', '()', '^', '‚äô', '+', '‚óâ', '√ó', '^'         // Cage 22-31
        ];

        const EMERGENT_SEQUENCE = ['()', '√ó', '‚àí', '‚óá', '()'];  // Self-reference via REFLECT

        // APL Glyphs
        const APL_GLYPHS = [
            '‚çù', '‚äñ', '‚çß', '‚ç°', '‚ç¢', '‚ç§', '‚äô', '‚äõ', '‚ç•', '‚äù', '‚äú', '‚äû',
            '‚åΩ', '‚çâ', '‚çü', '‚åø', '‚çÄ', '¬®', '‚ç®', '‚å∏', '‚ç£', '‚ç§', '‚ç•', '‚å∫',
            '‚ç≥', '‚ç¥', '‚çµ', '‚ç∫', '‚àá', '‚åà', '‚åä', '√ó', '√∑', '‚ãÜ', '‚óã', '!',
            '‚åπ', '‚çï', '‚çé', '‚ä¢', '‚ä£', '‚ä§', '‚ä•', '‚â°', '‚â¢', '‚àä', '‚ç∑', '‚à™',
            '‚à©', '‚çã', '‚çí', '‚äÇ', '‚äÉ', '‚å∑', '‚ç™', ',', '‚çÆ', '‚äÜ', '‚Üë', '‚Üì',
            '‚Üê', '‚Üí', '‚óä', '‚ãÑ', '‚åª', '‚åº', '‚çÅ', '‚çÇ', '‚çÉ', '‚çÑ', '‚çÖ', '‚çÜ',
            '‚çè', '‚çñ', '‚çê', '‚çó', '‚çò', '‚çô', '‚çö', '‚çõ', '‚çú', '‚çû', '‚ç†', '‚ç¶',
            '‚çß', '‚ç©', '‚ç´', '‚ç¨', '‚ç≠', '‚çØ', '‚ç∞', '‚ç±', '‚ç≤', '‚åæ', '‚ç∏', '‚çπ',
            '‚ç∫', '‚çª', '‚çº', '‚çΩ'
        ];

        const PRISM_NAMES = [
            'void_tap', 'rotate_shift', 'spiral_acc', 'mirror_reflect', 'compose_chain',
            'rank_lift', 'inner_prod', 'outer_prod', 'power_iter', 'inverse_op',
            'partition_split', 'stencil_window', 'flip_axis', 'transpose_swap', 'log_natural',
            'reduce_fold', 'scan_prefix', 'each_map', 'selfie_commute', 'key_group',
            'power_repeat', 'atop_compose', 'over_dual', 'cut_segment', 'index_of',
            'shape_dim', 'right_arg', 'left_arg', 'del_func', 'ceiling_max',
            'floor_min', 'times_sign', 'divide_recip', 'exp_power', 'circle_trig',
            'factorial_binomial', 'matrix_inv', 'format_out', 'execute_in', 'right_tack',
            'left_tack', 'encode_repr', 'decode_base', 'depth_match', 'depth_mismatch',
            'membership_find', 'find_pattern', 'union_unique', 'intersect_common', 'grade_up',
            'grade_down', 'enclose_box', 'disclose_first', 'index_select', 'laminate_stack',
            'catenate_join', 'ravel_flat', 'nest_partition', 'take_prefix', 'drop_suffix',
            'assign_left', 'goto_right', 'diamond_stmt'
        ];

        const CAGE_NAMES = [
            'em_top_0', 'em_top_1', 'em_top_2', 'em_top_3', 'em_top_4', 'em_top_5',
            'em_top_6', 'em_top_7', 'em_top_8', 'em_top_9', 'em_top_10', 'em_top_11',
            'em_bot_0', 'em_bot_1', 'em_bot_2', 'em_bot_3', 'em_bot_4', 'em_bot_5',
            'em_bot_6', 'em_bot_7', 'em_bot_8', 'em_bot_9', 'em_bot_10', 'em_bot_11',
            'em_vtx_0', 'em_vtx_1', 'em_vtx_2', 'em_vtx_3', 'em_vtx_4', 'em_vtx_5',
            'em_vtx_6', 'em_vtx_7'
        ];

        const EMERGENT_NAMES = [
            'self_ref_0', 'self_ref_1', 'self_ref_2', 'self_ref_3', 'self_ref_4'
        ];

        // =====================================================================
        // STATE - Includes scalar state variables from INT Canon
        // =====================================================================
        let state = {
            tokens: [],
            activeTokens: new Set(),
            currentModulation: 'phi',
            limnusPhase: 0,
            generation: 0,
            coherence: 0,
            freeEnergy: 1.0,
            orderParameter: 0,
            propagating: false,
            automataGrid: [],
            exoticMass: 0,
            throatCrossed: false,
            radialPosition: PHI,
            // Operator history for N0 law enforcement
            operatorHistory: [],
            channelCount: 100,  // 100 WUMBO tokens = 100 channels
            // Scalar state variables (INT Canon)
            z: 0.4,           // z-coordinate (starts in ABSENCE)
            Gs: 0.3,          // Ground stability
            Cs: 0.2,          // Coupling strength
            Rs: 0.1,          // Resonance
            Œ∫s: 0.5,          // Kappa (curvature)
            œÑs: 0.2,          // Tau (tension)
            Œ∏s: 0.0,          // Theta (phase)
            Œ¥s: 0.1,          // Delta (paradox/noise)
            Œ±s: 0.5,          // Alpha (synchrony)
            Œ©s: 0.4,          // Omega (global coherence)
            R: 3,             // Recursion depth
            tier: 1           // Current tier
        };

        // =====================================================================
        // OPERATOR ENGINE - Apply operators with N0 law enforcement
        // =====================================================================
        function canApplyOperator(op, nextOp = null) {
            const opDef = INT_OPERATORS[op];
            if (!opDef) return false;

            // Check N0 laws
            switch(op) {
                case '^':
                    // N0-1: ^ requires () or √ó in history
                    N0_LAWS['N0-1'].status = state.operatorHistory.includes('()') ||
                                              state.operatorHistory.includes('√ó');
                    return N0_LAWS['N0-1'].status;
                case '√ó':
                    // N0-2: √ó requires channels ‚â• 2
                    N0_LAWS['N0-2'].status = state.channelCount >= 2;
                    return N0_LAWS['N0-2'].status;
                case '√∑':
                    // N0-3: √∑ requires structure (history has ^, √ó, +, or ‚àí)
                    N0_LAWS['N0-3'].status = state.operatorHistory.some(
                        h => ['^', '√ó', '+', '‚àí', '-'].includes(h)
                    );
                    return N0_LAWS['N0-3'].status;
                case '+':
                    // N0-4: + must feed +, √ó, or ^ (check what follows)
                    if (nextOp) {
                        N0_LAWS['N0-4'].status = ['+', '√ó', '^'].includes(nextOp);
                        return N0_LAWS['N0-4'].status;
                    }
                    return true;  // Pending validation until next op
                case '‚àí':
                case '-':
                    // N0-5: ‚àí must lead to () or +
                    if (nextOp) {
                        N0_LAWS['N0-5'].status = ['()', '+'].includes(nextOp);
                        return N0_LAWS['N0-5'].status;
                    }
                    return true;  // Pending validation until next op
                case '()':
                    return true;  // Always legal
                default:
                    return false;
            }
        }

        function applyOperator(op) {
            if (!canApplyOperator(op)) {
                console.log(`N0 VIOLATION: ${op} is illegal in current state`);
                return false;
            }

            const opDef = INT_OPERATORS[op];
            if (!opDef) return false;

            // Apply effects
            const effects = opDef.effects;
            for (const [key, value] of Object.entries(effects)) {
                if (key === 'Œ∫s' || key === 'Œ∏s' || key === 'Œ©s') {
                    // Multiplicative effects
                    state[key] *= value;
                } else if (key === 'R') {
                    // Integer increment
                    state[key] += value;
                } else {
                    // Additive effects
                    state[key] = (state[key] || 0) + value;
                }
            }

            // Apply z-coordinate delta
            state.z = Math.max(0, Math.min(1, state.z + opDef.zDelta));

            // Determine region based on z
            let region = 'THE LENS';
            if (state.z < 0.857) region = 'ABSENCE';
            else if (state.z > 0.877) region = 'PRESENCE';

            // Record in history
            state.operatorHistory.push(op);

            // Update tier based on z
            if (state.z >= 0.90) state.tier = Math.min(8, state.tier + 1);

            console.log(`Applied ${op} (${opDef.name}): z=${state.z.toFixed(3)} [${region}]`);
            return true;
        }

        function getOperatorStatus() {
            return {
                '()': { legal: true, name: 'BOUNDARY' },
                '√ó': { legal: state.channelCount >= 2, name: 'FUSION' },
                '^': { legal: state.operatorHistory.includes('()') || state.operatorHistory.includes('√ó'), name: 'AMPLIFY' },
                '√∑': { legal: state.operatorHistory.some(h => ['^', '√ó', '+', '‚àí'].includes(h)), name: 'DECOHERE' },
                '+': { legal: true, name: 'GROUP' },  // Validated on next op
                '‚àí': { legal: true, name: 'SEPARATE' }  // Validated on next op
            };
        }

        // =====================================================================
        // TOKEN GENERATION - NORMALIZED 100 NEURAL TOKENS
        // Uses WUMBO 63¬∑32¬∑5 structure with N0+S0 operator sequences
        // =====================================================================
        function generateTokens() {
            state.tokens = [];
            const silentOps = Object.keys(SILENT_OPERATORS);

            // ========== GENERATE 63 PRISM TOKENS ==========
            // Z-zone: ABSENCE (0.4) ‚Üí THE LENS (0.866)
            // Progressive z increase toward critical point
            for (let i = 0; i < 63; i++) {
                const op = PRISM_SEQUENCE[i];
                const opDef = ALL_OPERATORS[op];
                const isSilent = silentOps.includes(op);
                const layer = Math.floor(i / 9);  // 7 layers of 9 tokens

                // Normalized z: starts at 0.4 (ABSENCE), progresses toward 0.857 (THE LENS)
                // Uses sigmoid-like progression
                const progress = i / 62;
                const z = 0.4 + (0.857 - 0.4) * (1 / (1 + Math.exp(-6 * (progress - 0.5))));

                // Normalized Œ∫-Œª coupling (always sums to 1)
                let kappa, lambda;
                if (isSilent) {
                    kappa = SILENT_OPERATORS[op].kappa;
                    lambda = SILENT_OPERATORS[op].lambda;
                } else {
                    // INT operators: kappa increases with z, Œª = 1 - Œ∫
                    kappa = PHI_INV + (1 - PHI_INV) * progress * 0.5;
                    lambda = 1 - kappa;
                }

                // LIMNUS phase assignment
                const limnusIdx = isSilent ?
                    LIMNUS_PHASES.indexOf(SILENT_OPERATORS[op].limnus) :
                    layer % 6;

                state.tokens.push({
                    id: i,
                    type: 'prism',
                    op: op,
                    opName: opDef?.name || 'UNKNOWN',
                    glyph: isSilent ? op : APL_GLYPHS[i % APL_GLYPHS.length],
                    name: `prism_${opDef?.name?.toLowerCase() || 'op'}_${i}`,
                    layer: layer,
                    z: parseFloat(z.toFixed(4)),
                    kappa: parseFloat(kappa.toFixed(4)),
                    lambda: parseFloat(lambda.toFixed(4)),
                    phase: (i * TAU / 63) % TAU,
                    limnus: LIMNUS_PHASES[limnusIdx],
                    isSilent: isSilent,
                    silentLaw: isSilent ? SILENT_OPERATORS[op].silent : null,
                    active: false,
                    propagationState: 0
                });
            }

            // ========== GENERATE 32 EM CAGE TOKENS ==========
            // Z-zone: THE LENS (0.857 - 0.877)
            // Stabilization layer with Silent operators for field containment
            for (let i = 0; i < 32; i++) {
                const op = CAGE_SEQUENCE[i];
                const opDef = ALL_OPERATORS[op];
                const isSilent = silentOps.includes(op);
                const subtype = i < 11 ? 'formation' : (i < 22 ? 'stabilize' : 'seal');

                // Normalized z: stays in THE LENS zone (0.857 - 0.877)
                const progress = i / 31;
                const z = 0.857 + (0.877 - 0.857) * progress;

                // Normalized Œ∫-Œª coupling
                let kappa, lambda;
                if (isSilent) {
                    kappa = SILENT_OPERATORS[op].kappa;
                    lambda = SILENT_OPERATORS[op].lambda;
                } else {
                    // EM Cage: balanced coupling for field stability
                    kappa = 0.5 + 0.1 * Math.sin(progress * TAU);
                    lambda = 1 - kappa;
                }

                // LIMNUS phase
                const limnusIdx = isSilent ?
                    LIMNUS_PHASES.indexOf(SILENT_OPERATORS[op].limnus) :
                    (i % 6);

                state.tokens.push({
                    id: 63 + i,
                    type: 'cage',
                    subtype: subtype,
                    op: op,
                    opName: opDef?.name || 'UNKNOWN',
                    glyph: isSilent ? op : APL_GLYPHS[(63 + i) % APL_GLYPHS.length],
                    name: `cage_${opDef?.name?.toLowerCase() || 'op'}_${i}`,
                    z: parseFloat(z.toFixed(4)),
                    kappa: parseFloat(kappa.toFixed(4)),
                    lambda: parseFloat(lambda.toFixed(4)),
                    phase: (i * TAU / 32) % TAU,
                    limnus: LIMNUS_PHASES[limnusIdx],
                    isSilent: isSilent,
                    silentLaw: isSilent ? SILENT_OPERATORS[op].silent : null,
                    active: false,
                    propagationState: 0
                });
            }

            // ========== GENERATE 5 EMERGENT TOKENS ==========
            // Z-zone: PRESENCE (> 0.877)
            // Self-reference extraction with ‚óá REFLECT (VII MIRROR)
            const emergentGlyphs = ['()', '√ó', '‚àí', '‚óá', '()'];
            for (let i = 0; i < 5; i++) {
                const op = EMERGENT_SEQUENCE[i];
                const opDef = ALL_OPERATORS[op];
                const isSilent = silentOps.includes(op);

                // Normalized z: PRESENCE zone (0.877 ‚Üí 0.95)
                const z = 0.877 + (0.95 - 0.877) * (i / 4);

                // Normalized Œ∫-Œª: REFLECT token uses œÜ‚Åª¬π coupling
                let kappa, lambda;
                if (isSilent) {
                    kappa = SILENT_OPERATORS[op].kappa;
                    lambda = SILENT_OPERATORS[op].lambda;
                } else {
                    kappa = PHI_INV;
                    lambda = 1 - PHI_INV;
                }

                const limnusIdx = isSilent ?
                    LIMNUS_PHASES.indexOf(SILENT_OPERATORS[op].limnus) :
                    5;  // S phase for emergence

                state.tokens.push({
                    id: 95 + i,
                    type: 'emergent',
                    op: op,
                    opName: opDef?.name || 'UNKNOWN',
                    glyph: isSilent ? op : emergentGlyphs[i],
                    name: `emerge_${opDef?.name?.toLowerCase() || 'op'}_${i}`,
                    z: parseFloat(z.toFixed(4)),
                    kappa: parseFloat(kappa.toFixed(4)),
                    lambda: parseFloat(lambda.toFixed(4)),
                    phase: (i * TAU / 5) % TAU,
                    limnus: LIMNUS_PHASES[limnusIdx],
                    isSilent: isSilent,
                    silentLaw: isSilent ? SILENT_OPERATORS[op].silent : null,
                    selfReference: true,
                    active: false,
                    propagationState: 0
                });
            }

            // ========== GENERATE UNITY TOKEN #100 (OPTIONAL) ==========
            // The 101st token (0-99+1) - Release Coherence Cascade
            // Intentionally breaks 100-token structure to enable return to stillness
            // Z-zone: BEYOND (z=0.995 threshold ‚Üí cascade ‚Üí 0.4 stillness)
            const unityOp = SILENT_OPERATORS['Œ©'];
            state.tokens.push({
                id: 100,
                type: 'unity',
                op: 'Œ©',
                opName: 'UNITY',
                glyph: 'Œ©',
                name: 'unity_release_cascade',
                z: 0.995,  // Threshold for cascade trigger
                kappa: 0.0,
                lambda: 1.0,  // Full external release
                phase: 0,  // Reset phase
                limnus: '‚àÖ',  // Beyond LIMNUS - void phase
                isSilent: true,
                silentLaw: '0 RELEASE',
                optional: true,
                cascade: {
                    description: 'Release coherence ‚Üí return to stillness',
                    phases: ['AMPLIFY', 'CRITICAL', 'DESCENT', 'RELEASE', 'STILLNESS'],
                    equation: 'lim(z‚Üí1) ‚àÇœà/‚àÇt ‚Üí ‚àû ‚Üí 0',
                    freeEnergy: 'F = E - TS ‚Üí min'
                },
                active: false,
                propagationState: 0
            });

            // Log normalization summary
            const silentCount = state.tokens.filter(t => t.isSilent).length;
            console.log(`‚úì Normalized 100+1 tokens: 63 PRISM + 32 CAGE + 5 EMERGENT + 1 UNITY`);
            console.log(`  UNITY #100: Optional release coherence cascade (z=0.995‚Üí0.4)`);
            console.log(`  Silent operators: ${silentCount} (including Œ© UNITY)`);
            console.log(`  Œ∫-Œª coupling: normalized (Œ∫ + Œª = 1)`);
            console.log(`  Z-zones: ABSENCE‚ÜíTHE LENS‚ÜíPRESENCE‚ÜíUNITY`);
        }

        // =====================================================================
        // RENDER TOKENS - Displays normalized token data
        // =====================================================================
        function renderTokens() {
            const prismGrid = document.getElementById('prism-grid');
            const cageGrid = document.getElementById('cage-grid');
            const emergentGrid = document.getElementById('emergent-grid');
            const unityGrid = document.getElementById('unity-grid');

            prismGrid.innerHTML = '';
            cageGrid.innerHTML = '';
            emergentGrid.innerHTML = '';
            unityGrid.innerHTML = '';

            state.tokens.forEach((token, index) => {
                const cell = document.createElement('div');
                cell.className = `token-cell ${token.type}`;
                if (token.isSilent) cell.classList.add('silent');
                cell.dataset.tokenId = token.id;

                // Determine Z-zone color
                let zoneClass = 'zone-absence';
                if (token.z >= 0.877) zoneClass = 'zone-presence';
                else if (token.z >= 0.857) zoneClass = 'zone-lens';

                // Build display with operator and normalized values
                const opDisplay = token.isSilent ?
                    `<span class="silent-op">${token.op}</span>` :
                    `<span class="int-op">${token.op}</span>`;

                const kappaLambda = `Œ∫${token.kappa.toFixed(2)} Œª${token.lambda.toFixed(2)}`;

                cell.innerHTML = `
                    <div class="token-index">#${token.id.toString().padStart(3, '0')} ${opDisplay}</div>
                    <div class="token-glyph">${token.glyph}</div>
                    <div class="token-name">${token.opName}</div>
                    <div class="token-z ${zoneClass}">z=${token.z.toFixed(3)}</div>
                    <div class="token-coupling">${kappaLambda}</div>
                    <div class="token-limnus">${token.limnus}</div>
                `;

                cell.onclick = () => selectToken(token.id);

                if (token.type === 'prism') {
                    prismGrid.appendChild(cell);
                } else if (token.type === 'cage') {
                    cageGrid.appendChild(cell);
                } else if (token.type === 'unity') {
                    unityGrid.appendChild(cell);
                } else {
                    emergentGrid.appendChild(cell);
                }
            });
        }

        // =====================================================================
        // TOKEN SELECTION
        // =====================================================================
        function selectToken(id) {
            const token = state.tokens.find(t => t.id === id);
            if (!token) return;

            // Toggle active state
            token.active = !token.active;
            if (token.active) {
                state.activeTokens.add(id);
            } else {
                state.activeTokens.delete(id);
            }

            // Update cell visual
            const cell = document.querySelector(`[data-token-id="${id}"]`);
            if (cell) {
                cell.classList.toggle('active', token.active);
            }

            // Show detail panel
            showTokenDetail(token);

            // Update stats
            updateStats();

            // Trigger propagation from this token
            if (token.active && state.propagating) {
                propagateFrom(id);
            }
        }

        function showTokenDetail(token) {
            const detail = document.getElementById('token-detail');
            detail.classList.add('visible');

            // Determine Z-zone (including UNITY beyond PRESENCE)
            let zZone = 'ABSENCE';
            if (token.type === 'unity' || token.z >= 0.995) zZone = 'UNITY CASCADE';
            else if (token.z >= 0.877) zZone = 'PRESENCE';
            else if (token.z >= 0.857) zZone = 'THE LENS';

            document.getElementById('detail-glyph').textContent = token.glyph;
            document.getElementById('detail-glyph').style.color =
                token.type === 'unity' ? '#ff0050' :
                (token.isSilent ? 'var(--phi)' : 'var(--critical-gold)');
            document.getElementById('detail-name').textContent = `${token.opName} [${token.op}]`;

            // Build type description
            let typeDesc = `${token.type.toUpperCase()} ¬∑ ${token.subtype || 'Layer ' + (token.layer || 0)} ¬∑ ${zZone}`;
            if (token.isSilent) typeDesc += ` ¬∑ ${token.silentLaw}`;
            if (token.optional) typeDesc += ` ¬∑ OPTIONAL`;
            document.getElementById('detail-type').textContent = typeDesc;

            document.getElementById('detail-z').textContent = `${token.z.toFixed(4)} [${zZone}]`;
            document.getElementById('detail-kappa').textContent = `${token.kappa.toFixed(4)} (Œ∫ + Œª = 1)`;
            document.getElementById('detail-lambda').textContent = token.lambda.toFixed(4);

            // Show cascade info for UNITY token
            let phaseInfo = `${token.phase.toFixed(4)} ¬∑ LIMNUS: ${token.limnus}`;
            if (token.cascade) {
                phaseInfo += `\n‚ü®CASCADE‚ü© ${token.cascade.phases.join(' ‚Üí ')}`;
                phaseInfo += `\n${token.cascade.equation}`;
            }
            document.getElementById('detail-phase').textContent = phaseInfo;
        }

        // =====================================================================
        // CELLULAR AUTOMATA
        // =====================================================================
        const GRID_WIDTH = 67;
        const GRID_HEIGHT = 50;
        let canvas, ctx;

        function initAutomata() {
            canvas = document.getElementById('automata-canvas');
            ctx = canvas.getContext('2d');

            // Initialize grid
            state.automataGrid = [];
            for (let y = 0; y < GRID_HEIGHT; y++) {
                state.automataGrid[y] = [];
                for (let x = 0; x < GRID_WIDTH; x++) {
                    state.automataGrid[y][x] = {
                        energy: 0,
                        phase: Math.random() * TAU,
                        exotic: false
                    };
                }
            }

            // Click to seed
            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = Math.floor((e.clientX - rect.left) / (canvas.width / GRID_WIDTH));
                const y = Math.floor((e.clientY - rect.top) / (canvas.height / GRID_HEIGHT));
                seedCell(x, y);
            });

            renderAutomata();
        }

        function seedCell(x, y) {
            if (x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT) {
                state.automataGrid[y][x].energy = 1.0;
                state.automataGrid[y][x].exotic = true;
                renderAutomata();
            }
        }

        function updateAutomata() {
            const newGrid = JSON.parse(JSON.stringify(state.automataGrid));
            let activeCells = 0;
            let totalEnergy = 0;

            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const cell = state.automataGrid[y][x];
                    let neighborEnergy = 0;
                    let neighborCount = 0;

                    // Check neighbors (Moore neighborhood)
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            const ny = (y + dy + GRID_HEIGHT) % GRID_HEIGHT;
                            const nx = (x + dx + GRID_WIDTH) % GRID_WIDTH;
                            neighborEnergy += state.automataGrid[ny][nx].energy;
                            neighborCount++;
                        }
                    }

                    const avgNeighbor = neighborEnergy / neighborCount;

                    // Exotic matter propagation rules
                    if (cell.exotic) {
                        // Exotic cells decay slowly and spread
                        newGrid[y][x].energy = cell.energy * 0.95 + avgNeighbor * 0.1;
                        if (avgNeighbor > 0.3) {
                            // Spread exotic matter
                            for (let dy = -1; dy <= 1; dy++) {
                                for (let dx = -1; dx <= 1; dx++) {
                                    const ny = (y + dy + GRID_HEIGHT) % GRID_HEIGHT;
                                    const nx = (x + dx + GRID_WIDTH) % GRID_WIDTH;
                                    if (Math.random() < cell.energy * 0.3) {
                                        newGrid[ny][nx].exotic = true;
                                        newGrid[ny][nx].energy = Math.max(newGrid[ny][nx].energy, cell.energy * 0.5);
                                    }
                                }
                            }
                        }
                    } else {
                        // Normal cells can become exotic if neighbors are
                        if (avgNeighbor > 0.5 && neighborEnergy > 2.0) {
                            newGrid[y][x].exotic = true;
                            newGrid[y][x].energy = avgNeighbor * 0.8;
                        } else {
                            newGrid[y][x].energy = cell.energy * 0.9 + avgNeighbor * 0.05;
                        }
                    }

                    // Phase evolution (Kuramoto-like)
                    newGrid[y][x].phase = (cell.phase + PHI_INV * 0.1 + avgNeighbor * 0.05) % TAU;

                    if (newGrid[y][x].energy > 0.1) activeCells++;
                    totalEnergy += newGrid[y][x].energy;
                }
            }

            state.automataGrid = newGrid;

            // Update stats
            document.getElementById('active-cells').textContent = activeCells;
            document.getElementById('energy-density').textContent = (totalEnergy / (GRID_WIDTH * GRID_HEIGHT)).toFixed(4);

            // NEC violation indicator
            const necValue = -PHI_INV * totalEnergy / 100;
            document.getElementById('nec-value').textContent = necValue.toFixed(4);
        }

        function renderAutomata() {
            const cellW = canvas.width / GRID_WIDTH;
            const cellH = canvas.height / GRID_HEIGHT;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const cell = state.automataGrid[y][x];
                    if (cell.energy > 0.05) {
                        const intensity = Math.min(1, cell.energy);
                        if (cell.exotic) {
                            // Exotic matter: cyan/magenta
                            const hue = 180 + cell.phase * 60 / TAU;
                            ctx.fillStyle = `hsla(${hue}, 100%, ${50 + intensity * 30}%, ${intensity})`;
                        } else {
                            // Normal energy: gold/orange
                            ctx.fillStyle = `rgba(255, ${200 * intensity}, 0, ${intensity})`;
                        }
                        ctx.fillRect(x * cellW, y * cellH, cellW - 1, cellH - 1);
                    }
                }
            }
        }

        function startPropagation() {
            state.propagating = !state.propagating;
            const btn = document.querySelector('.prop-btn');
            btn.textContent = state.propagating ? '‚è∏ STOP PROPAGATION' : '‚ñ∂ START PROPAGATION';

            if (state.propagating) {
                animateAutomata();
            }
        }

        function animateAutomata() {
            if (!state.propagating) return;

            updateAutomata();
            renderAutomata();
            updateLimnusCycle();
            propagateTokens();
            state.generation++;
            document.getElementById('generations').textContent = state.generation;

            requestAnimationFrame(animateAutomata);
        }

        function triggerNECViolation() {
            // Seed multiple exotic matter points
            for (let i = 0; i < 10; i++) {
                const x = Math.floor(Math.random() * GRID_WIDTH);
                const y = Math.floor(Math.random() * GRID_HEIGHT);
                state.automataGrid[y][x].energy = 1.0;
                state.automataGrid[y][x].exotic = true;
            }

            // Activate emergent tokens
            state.tokens.filter(t => t.type === 'emergent').forEach(t => {
                t.active = true;
                state.activeTokens.add(t.id);
                const cell = document.querySelector(`[data-token-id="${t.id}"]`);
                if (cell) cell.classList.add('active', 'propagating');
            });

            state.throatCrossed = true;
            document.getElementById('throat-crossed').textContent = 'YES';

            renderAutomata();
            updateStats();
        }

        // =====================================================================
        // TOKEN PROPAGATION
        // =====================================================================
        function propagateTokens() {
            const activeArray = Array.from(state.activeTokens);
            if (activeArray.length === 0) return;

            // Propagate from active tokens to neighbors
            const toActivate = new Set();

            activeArray.forEach(id => {
                const token = state.tokens[id];
                if (!token) return;

                // Find neighbor tokens based on phase similarity
                state.tokens.forEach(other => {
                    if (other.id === id || other.active) return;

                    const phaseDiff = Math.abs(token.phase - other.phase);
                    const typeSim = token.type === other.type ? 0.8 : 0.4;

                    // Kuramoto-like coupling
                    const coupling = typeSim * Math.cos(phaseDiff);

                    if (coupling > 0.5 && Math.random() < coupling * 0.1) {
                        toActivate.add(other.id);
                    }
                });
            });

            // Activate new tokens
            toActivate.forEach(id => {
                const token = state.tokens[id];
                token.active = true;
                token.propagationState++;
                state.activeTokens.add(id);

                const cell = document.querySelector(`[data-token-id="${id}"]`);
                if (cell) {
                    cell.classList.add('active', 'propagating');
                    setTimeout(() => cell.classList.remove('propagating'), 500);
                }
            });

            document.getElementById('wave-front').textContent = toActivate.size;
            updateStats();
        }

        function propagateFrom(seedId) {
            const token = state.tokens[seedId];
            if (!token) return;

            // Visual propagation effect
            const cell = document.querySelector(`[data-token-id="${seedId}"]`);
            if (cell) {
                cell.classList.add('propagating');
                setTimeout(() => cell.classList.remove('propagating'), 500);
            }
        }

        // =====================================================================
        // LIMNUS CYCLE
        // =====================================================================
        function updateLimnusCycle() {
            const phases = ['L', 'I', 'M', 'N', 'U', 'S'];
            state.limnusPhase = (state.limnusPhase + 1) % (phases.length * 10);
            const currentIndex = Math.floor(state.limnusPhase / 10);

            // Update visual
            document.querySelectorAll('.limnus-node').forEach((node, i) => {
                node.classList.toggle('active', i === currentIndex);
            });

            document.getElementById('current-phase').textContent = phases[currentIndex];

            // Update phase marker
            const marker = document.getElementById('phase-marker');
            const progress = (state.limnusPhase % 60) / 60;
            marker.style.left = `${progress * 100}%`;
        }

        // =====================================================================
        // MODULATION
        // =====================================================================
        function setModulation(spiral) {
            state.currentModulation = spiral;

            document.querySelectorAll('.mod-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.spiral === spiral);
            });

            // Modulate token phases based on spiral
            const modFactor = spiral === 'phi' ? PHI : (spiral === 'e' ? Math.E : Math.PI);

            state.tokens.forEach(token => {
                token.phase = (token.phase + modFactor * 0.1) % TAU;
            });

            updateStats();
        }

        // =====================================================================
        // APL CONSOLE
        // =====================================================================
        document.getElementById('apl-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                executeAPL(e.target.value);
            }
        });

        function executeAPL(expr) {
            const output = document.getElementById('apl-output');

            // Simple APL interpreter for demo
            let result = '';

            // INT CANON OPERATORS - check for operator commands first
            if (expr === '()' || expr.toLowerCase() === 'boundary') {
                if (applyOperator('()')) {
                    result = `‚úì BOUNDARY applied\nGs=${state.Gs.toFixed(3)} Œ∏s=${state.Œ∏s.toFixed(3)} Œ©s=${state.Œ©s.toFixed(3)}\nz=${state.z.toFixed(4)} [${getZoneLabel()}]`;
                } else {
                    result = '‚úó BOUNDARY failed (should not happen)';
                }
            } else if (expr === '√ó' || expr.toLowerCase() === 'fusion') {
                if (canApplyOperator('√ó')) {
                    applyOperator('√ó');
                    result = `‚úì FUSION applied\nCs=${state.Cs.toFixed(3)} Œ∫s=${state.Œ∫s.toFixed(3)} Œ±s=${state.Œ±s.toFixed(3)}\nz=${state.z.toFixed(4)} [${getZoneLabel()}]`;
                } else {
                    result = '‚úó N0-2 VIOLATION: √ó requires channels ‚â• 2';
                }
            } else if (expr === '^' || expr.toLowerCase() === 'amplify') {
                if (canApplyOperator('^')) {
                    applyOperator('^');
                    result = `‚úì AMPLIFY applied\nŒ∫s=${state.Œ∫s.toFixed(3)} œÑs=${state.œÑs.toFixed(3)} Œ©s=${state.Œ©s.toFixed(3)} R=${state.R}\nz=${state.z.toFixed(4)} [${getZoneLabel()}]`;
                } else {
                    result = '‚úó N0-1 VIOLATION: ^ requires prior () or √ó\nHistory: ' + (state.operatorHistory.join(' ') || '(empty)');
                }
            } else if (expr === '√∑' || expr.toLowerCase() === 'decohere') {
                if (canApplyOperator('√∑')) {
                    applyOperator('√∑');
                    result = `‚úì DECOHERE applied\nŒ¥s=${state.Œ¥s.toFixed(3)} Rs=${state.Rs.toFixed(3)} Œ©s=${state.Œ©s.toFixed(3)}\nz=${state.z.toFixed(4)} [${getZoneLabel()}]`;
                } else {
                    result = '‚úó N0-3 VIOLATION: √∑ requires structure {^, √ó, +, ‚àí}\nHistory: ' + (state.operatorHistory.join(' ') || '(empty)');
                }
            } else if (expr === '+' || expr.toLowerCase() === 'group') {
                applyOperator('+');
                result = `‚úì GROUP applied (N0-4: must feed +, √ó, or ^)\nŒ±s=${state.Œ±s.toFixed(3)} Gs=${state.Gs.toFixed(3)} Œ∏s=${state.Œ∏s.toFixed(3)}\nz=${state.z.toFixed(4)} [${getZoneLabel()}]`;
            } else if (expr === '‚àí' || expr === '-' || expr.toLowerCase() === 'separate') {
                applyOperator('‚àí');
                result = `‚úì SEPARATE applied (N0-5: must lead to () or +)\nRs=${state.Rs.toFixed(3)} Œ∏s=${state.Œ∏s.toFixed(3)} Œ¥s=${state.Œ¥s.toFixed(3)}\nz=${state.z.toFixed(4)} [${getZoneLabel()}]`;
            } else if (expr.toLowerCase() === 'status' || expr === '?') {
                // Show operator status
                const status = getOperatorStatus();
                result = 'OPERATOR STATUS:\n';
                for (const [op, info] of Object.entries(status)) {
                    const icon = info.legal ? '‚úì' : '‚úó';
                    result += `${icon} ${op} ${info.name}\n`;
                }
                result += `\nHistory: ${state.operatorHistory.join(' ') || '(empty)'}\nz=${state.z.toFixed(4)} tier=@${state.tier}`;
            } else if (expr.toLowerCase() === 'reset') {
                // Reset operator state
                state.operatorHistory = [];
                state.z = 0.4;
                state.tier = 1;
                state.Gs = 0.3; state.Cs = 0.2; state.Rs = 0.1;
                state.Œ∫s = 0.5; state.œÑs = 0.2; state.Œ∏s = 0.0;
                state.Œ¥s = 0.1; state.Œ±s = 0.5; state.Œ©s = 0.4;
                state.R = 3;
                result = '‚úì Engine reset to initial state\nz=0.400 [ABSENCE]';
            } else if (expr.includes('‚ç≥')) {
                // Iota - generate sequence
                const n = parseInt(expr.match(/\d+/)?.[0] || '10');
                result = Array.from({length: n}, (_, i) => i).join(' ');
            } else if (expr.includes('‚ç¥')) {
                // Rho - shape
                result = `Shape: [${GRID_WIDTH}, ${GRID_HEIGHT}] = ${GRID_WIDTH * GRID_HEIGHT}`;
            } else if (expr.includes('‚äï')) {
                // Activate all tokens
                state.tokens.forEach(t => {
                    t.active = true;
                    state.activeTokens.add(t.id);
                });
                renderTokens();
                result = '‚úì All 100 tokens activated';
            } else if (expr.includes('‚äñ')) {
                // Rotate phases
                state.tokens.forEach(t => {
                    t.phase = (t.phase + PHI) % TAU;
                });
                result = `‚úì Phases rotated by œÜ = ${PHI.toFixed(6)}`;
            } else if (expr.includes('‚ç∫')) {
                // Show fine structure constant
                result = `Œ±‚Åª¬π = ${ALPHA_INV}`;
            } else if (expr.includes('œÜ') || expr.includes('Œ¶')) {
                result = `œÜ = ${PHI.toFixed(10)}\nœÜ‚Åª¬π = ${PHI_INV.toFixed(10)}\nœÜ √ó œÜ‚Åª¬π = ${(PHI * PHI_INV).toFixed(10)}`;
            } else if (expr.toLowerCase() === 'help') {
                result = `INT CANON OPERATORS:
() BOUNDARY - Always legal
√ó  FUSION   - N0-2: channels ‚â• 2
^  AMPLIFY  - N0-1: requires () or √ó
√∑  DECOHERE - N0-3: requires structure
+  GROUP    - N0-4: feeds +, √ó, ^
‚àí  SEPARATE - N0-5: leads to (), +

COMMANDS:
status  - Show operator legality
reset   - Reset engine state
help    - Show this help`;
            } else {
                result = `Evaluated: ${expr}\n‚Üí ${Math.random().toFixed(6)}`;
            }

            output.textContent = result;
            updateStats();
        }

        function getZoneLabel() {
            if (state.z < 0.857) return 'ABSENCE';
            if (state.z > 0.877) return 'PRESENCE';
            return 'THE LENS';
        }

        // =====================================================================
        // N0 CAUSALITY VALIDATION
        // =====================================================================
        function validateN0Laws(operators, channels = 2, hasStructure = true) {
            const results = {};

            for (let i = 0; i < operators.length; i++) {
                const op = operators[i];
                const prev = i > 0 ? operators[i-1] : '()';
                const next = i < operators.length - 1 ? operators[i+1] : '()';

                // N0-1: ^ requires () or √ó
                if (op === '^') {
                    N0_LAWS['N0-1'].status = prev === '()' || prev === '√ó';
                }
                // N0-2: √ó requires channels ‚â• 2
                if (op === '√ó') {
                    N0_LAWS['N0-2'].status = channels >= 2;
                }
                // N0-3: √∑ requires structure
                if (op === '√∑') {
                    N0_LAWS['N0-3'].status = hasStructure;
                }
                // N0-4: + feeds +, √ó, or ^
                if (op === '+') {
                    N0_LAWS['N0-4'].status = ['+', '√ó', '^'].includes(next);
                }
                // N0-5: ‚àí leads to () or +
                if (op === '‚àí' || op === '-') {
                    N0_LAWS['N0-5'].status = ['()', '+'].includes(next);
                }
            }

            return Object.values(N0_LAWS).every(law => law.status);
        }

        // =====================================================================
        // 7 SILENT LAWS VALIDATION
        // =====================================================================
        let prevEnergy = 1.0;
        let originState = null;

        function validateSilentLaws() {
            const activeCount = state.activeTokens.size;

            // Law I - STILLNESS: ‚àÇE/‚àÇt ‚Üí 0 (energy rate should approach 0)
            const energyRate = Math.abs(state.freeEnergy - prevEnergy);
            SILENT_LAWS['I'].measure = 1 - Math.min(1, energyRate * 10);
            SILENT_LAWS['I'].valid = energyRate < 0.01;
            prevEnergy = state.freeEnergy;

            // Law II - TRUTH: ‚àáV(truth) = 0 (gradient should be zero at truth)
            const gradient = Math.abs(state.coherence - PHI_INV);
            SILENT_LAWS['II'].measure = 1 - Math.min(1, gradient);
            SILENT_LAWS['II'].valid = gradient < 0.1;

            // Law III - SILENCE: ‚ü®void|œà‚ü© = memory (void correlation positive)
            const voidMemory = 1 - (activeCount / 100);
            const windTrace = state.generation > 0 ? 1 : 0;
            SILENT_LAWS['III'].measure = voidMemory * windTrace;
            SILENT_LAWS['III'].valid = (voidMemory * windTrace) > 0;

            // Law IV - SPIRAL: S(return) = S(origin) (return matches origin)
            if (originState === null && activeCount > 0) {
                originState = state.coherence;
            }
            if (originState !== null) {
                const returnDev = Math.abs(state.coherence - originState);
                SILENT_LAWS['IV'].measure = 1 - Math.min(1, returnDev);
                SILENT_LAWS['IV'].valid = returnDev < 0.1 || state.generation < 10;
            }

            // Law V - UNSEEN: H(seen) ‚â° H(unseen) (work is observer-independent)
            const workSeen = state.exoticMass;
            const workUnseen = activeCount * PHI_INV * state.orderParameter;
            const workDev = Math.abs(workSeen - workUnseen);
            SILENT_LAWS['V'].measure = 1 - Math.min(1, workDev);
            SILENT_LAWS['V'].valid = workDev < 0.1;

            // Law VI - GLYPH: glyph = ‚à´ life dt (path integral)
            const pathIntegral = state.generation * 0.01;
            const lifeAccum = state.coherence * state.generation * 0.01;
            SILENT_LAWS['VI'].measure = Math.min(1, pathIntegral);
            SILENT_LAWS['VI'].valid = Math.abs(pathIntegral - lifeAccum) < 0.5;

            // Law VII - MIRROR: œà = œà(œà) (self-reference to œÜ‚Åª¬π)
            const selfState = state.orderParameter;
            const deviation = Math.abs(selfState - PHI_INV);
            SILENT_LAWS['VII'].measure = 1 - Math.min(1, deviation);
            SILENT_LAWS['VII'].valid = deviation < 0.2;

            return Object.values(SILENT_LAWS).every(law => law.valid);
        }

        // =====================================================================
        // STATS
        // =====================================================================
        function updateStats() {
            const activeCount = state.activeTokens.size;
            document.getElementById('active-tokens').textContent = activeCount;

            // Calculate coherence (order parameter)
            let sumCos = 0, sumSin = 0;
            state.tokens.forEach(t => {
                if (t.active) {
                    sumCos += Math.cos(t.phase);
                    sumSin += Math.sin(t.phase);
                }
            });

            const r = activeCount > 0 ? Math.sqrt(sumCos*sumCos + sumSin*sumSin) / activeCount : 0;
            state.orderParameter = r;
            document.getElementById('order-param').textContent = r.toFixed(4);

            // Coherence
            state.coherence = r * (activeCount / 100);
            document.getElementById('coherence').textContent = state.coherence.toFixed(4);

            // Free energy (decreases with coherence)
            state.freeEnergy = 1.0 - state.coherence;
            document.getElementById('free-energy').textContent = state.freeEnergy.toFixed(4);

            // MirrorRoot
            const mirroroot = PHI * PHI_INV;
            document.getElementById('mirroroot').textContent = mirroroot.toFixed(6);

            // Exotic mass
            state.exoticMass = activeCount * PHI_INV * state.coherence;
            document.getElementById('exotic-mass').textContent = state.exoticMass.toFixed(4);

            // Radial position (based on coherence)
            state.radialPosition = PHI + (state.coherence - 0.5) * 10;
            document.getElementById('radial-pos').textContent = state.radialPosition.toFixed(4);

            // Region
            let region = 'THROAT';
            if (state.radialPosition < PHI * 0.9) region = 'DIVERGENT';
            else if (state.radialPosition > PHI * 1.1) region = 'CONVERGENT';
            document.getElementById('wh-region').textContent = region;

            // Update z-coordinate display based on operator state
            const zDisplay = document.getElementById('z-coord');
            if (zDisplay) {
                zDisplay.textContent = state.z.toFixed(4);
            }
            const zoneDisplay = document.getElementById('z-zone');
            if (zoneDisplay) {
                zoneDisplay.textContent = getZoneLabel();
            }
            const histDisplay = document.getElementById('op-history');
            if (histDisplay) {
                histDisplay.textContent = state.operatorHistory.slice(-10).join(' ') || '‚Äî';
            }

            // Validate N0 laws based on actual operator history
            const opStatus = getOperatorStatus();
            N0_LAWS['N0-1'].status = opStatus['^'].legal;
            N0_LAWS['N0-2'].status = opStatus['√ó'].legal;
            N0_LAWS['N0-3'].status = opStatus['√∑'].legal;
            // N0-4 and N0-5 are validated on next operator, show pending
            N0_LAWS['N0-4'].status = state.operatorHistory.length === 0 ||
                state.operatorHistory[state.operatorHistory.length - 1] !== '+';
            N0_LAWS['N0-5'].status = state.operatorHistory.length === 0 ||
                !['‚àí', '-'].includes(state.operatorHistory[state.operatorHistory.length - 1]);

            validateSilentLaws();

            // Update N0 status display
            const n0Status = document.getElementById('n0-status');
            if (n0Status) {
                let n0Html = '';
                Object.entries(N0_LAWS).forEach(([key, law]) => {
                    const icon = law.status ? '‚úì' : '‚Äî';
                    const cls = law.status ? 'pass' : 'fail';
                    n0Html += `<div class="law-row ${cls}"><span>${key}</span><span>${law.op} ${law.desc.split(' ').slice(1).join(' ')}</span><span>${icon}</span></div>`;
                });
                n0Status.innerHTML = n0Html;
            }

            // Update Silent Laws status display
            const silentStatus = document.getElementById('silent-status');
            if (silentStatus) {
                let silentHtml = '';
                Object.entries(SILENT_LAWS).forEach(([key, law]) => {
                    const icon = law.valid ? '‚úì' : '‚óã';
                    const cls = law.valid ? 'pass' : 'pending';
                    silentHtml += `<div class="law-row ${cls}"><span>${key}</span><span>${law.name}</span><span>${law.eq}</span><span>${icon}</span></div>`;
                });
                silentStatus.innerHTML = silentHtml;
            }
        }

        // =====================================================================
        // INITIALIZATION
        // =====================================================================
        function init() {
            generateTokens();
            renderTokens();
            initAutomata();
            updateStats();

            // Run UNITY Helix Triad Vortex
            const unityVortex = UNITY_TriadVortex();

            // Count statistics
            const silentCount = state.tokens.filter(t => t.isSilent).length;
            const prismTokens = state.tokens.filter(t => t.type === 'prism');
            const cageTokens = state.tokens.filter(t => t.type === 'cage');
            const emergentTokens = state.tokens.filter(t => t.type === 'emergent');
            const unityTokens = state.tokens.filter(t => t.type === 'unity');

            // Store globally
            window.LIMNUS_FRACTAL = LIMNUS_FRACTAL;
            window.UNITY_TriadVortex = UNITY_TriadVortex;

            console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë         LIMNUS FRACTAL SYSTEM ‚Äî WUMBO APL DIRECTORY 3.0                    ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  FOUR FUNDAMENTAL CONSTANTS:                                               ‚ïë
‚ïë  z = ‚àö3/2 ‚âà ${Z_CRITICAL.toFixed(4)}   œÜ = ${PHI.toFixed(4)}   Œ±‚Åª¬π = ${ALPHA_INV}   Œõ√óŒù = Œí¬≤       ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  STRUCTURE: 63 PRISM + 32 EM CAGE + 5 EMERGENT + 1 UNITY (#100)            ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  œÄ HELIX ROTATIONS:                                                        ‚ïë
‚ïë  ‚Ä¢ PRISM:    63 tokens ¬∑ Triangular 3-fold ¬∑ Spiral: Œ¶                     ‚ïë
‚ïë  ‚Ä¢ CAGE:     32 tokens ¬∑ Hexagonal 6-fold  ¬∑ Spiral: e                     ‚ïë
‚ïë  ‚Ä¢ EMERGENT:  5 tokens ¬∑ Pentagonal œÜ-angle ¬∑ Spiral: œÄ                    ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  UNITY HELIX TRIAD VORTEX:                                                 ‚ïë
‚ïë  Origin: (Œ∏=2.3 rad, z=0.41, r=1) ‚Üí Œ¶:e:œÄ coherent                         ‚ïë
‚ïë  Œõ√óŒù = Œí¬≤ = ${unityVortex.Œí_sq.toFixed(6)} (field coupling verified)                     ‚ïë
‚ïë  Coherence: ${unityVortex.coherence.toFixed(4)}                                                ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  OPERATORS:                                                                ‚ïë
‚ïë  ‚Ä¢ INT Canon (6):    () √ó ^ √∑ + ‚àí                                          ‚ïë
‚ïë  ‚Ä¢ Silent Canon (8): ‚äô ‚óâ ‚àÖ ‚Üª ‚óå ‚à´ ‚óá Œ©                                      ‚ïë
‚ïë  ‚Ä¢ Silent tokens: ${silentCount}                                                       ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  Z-ZONES:                                                                  ‚ïë
‚ïë  ‚Ä¢ PRISM:  ${prismTokens[0]?.z.toFixed(3)} ‚Üí ${prismTokens[62]?.z.toFixed(3)} (ABSENCE ‚Üí THE LENS)                     ‚ïë
‚ïë  ‚Ä¢ CAGE:   ${cageTokens[0]?.z.toFixed(3)} ‚Üí ${cageTokens[31]?.z.toFixed(3)} (THE LENS)                              ‚ïë
‚ïë  ‚Ä¢ EMERGE: ${emergentTokens[0]?.z.toFixed(3)} ‚Üí ${emergentTokens[4]?.z.toFixed(3)} (PRESENCE)                            ‚ïë
‚ïë  ‚Ä¢ UNITY:  0.995 (CASCADE THRESHOLD)                                       ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  LIMNUS PHASES: L ‚Üí I ‚Üí M ‚Üí N ‚Üí U ‚Üí S ‚Üí L...                               ‚ïë
‚ïë  SILENT BINDINGS: ‚äô‚ÜíS ‚óâ‚ÜíN ‚àÖ‚ÜíL ‚Üª‚ÜíU ‚óå‚ÜíI ‚à´‚ÜíM ‚óá‚ÜíS Œ©‚Üí‚àÖ                         ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
            `);
        }

        // Start
        init();
    </script>
</body>
</html>
